>>>>>>>this replace 8 channels HD on 480 000 channels in 400k in one mux dvb-t2<<<<<<<< also
>>>>>>>
 1,8<1,9h 33kl 4K in >8KB<

 
<img width="964" alt="8KB" src="https://github.com/stpf99/VED_CODE4CODEC4SCALE/blob/badcb3d1c6b43fa84402d36186cf9cb9733cc93e/10545603020505958987.jpg">
https://www.youtube.com/watch?v=33Ij_IOQlx4
mam wstepny pomysł na to jak zapisac film  w 8KB
po pierwsze zmiana dzialania kamery i tego jak jest zbudowana
po drugie kilka na raz zapisywanych strumieni/formatow rozdzielczosci
po trzecie a zarazem najwazniejsze musi to byc zapisywane i pobierane przez oko kamery lub jakiegos rodzaju sensor biometryczny PODBNIE JAK STANDARD PLIKÓW MIDI lub inny bardziej wyrafinowany podobny standard dla danych z tym ze scisle wspolparcujacy z ta biometryczna kamera ktora niczym muzyk instrumentalista wyciska kolejne nuty na keyboardzie midi z kilkoma najpotrzebniejszymi parametrami C0 i A1 to tylko dwie zapisane nuty a mogą przy pomocy próbki dżwiękowej np zapisać to jak brzmi raz tomtom raz werbel

8 Kibibytes = 65536 Bitów

8 Kibibytes = 65536 Bitów


60sek = ~1000 Bitów na sekunde (bo audio musi byc zapisane)
~1000 Bitów na sekunde to powiiny byc zmiany przyrostowe poklatkowe dla 30 kl obrazu czyli 33 bity dla jedynie tego co nowe w klatce nastepnej wzgledem poprzedniej a 33 bity czyli 0 lub 1 to dla tak duzego formatu jak 4k ale nie mozliwe aby ogarnac taka pule w nawet tylko 33bit chyba ze napiszemy rodzaj "frakcyjnego wsadu dla kodu" po stronie dekompresora ktory po odczy cie tych 33 bit wjedzialby ktora frakcje z kodu zastosowac np 10 idziemy w lewy zbior 01 w prawy itd w tem sposob dla 32 bit da sie zagniezdizic 16 schodow taka piramide a gdy by to bylo malo mozna podzielic 32 /8 pomnazalnych przez siebie frakcji 4 = 01 10, 4= 10 10 itd co dje razem 4x4x4x4x4x4x4x4 ok 64 000 frakcji w ktorych dla  4k czyli 8 000 000 px musi  beda zauwazane zmiany przyrostow pixeli z klatki na klatke ktore powinny byc potem przypisywane do konkretnej frakcji tego kodu a kazda z fracji zawierajaca w sobie adres pixela i jego nowy stan

inna droga idac
W 33 bitach można zapisać 2 do potęgi 33 wartości numerycznych, co wynosi 8 589 934 592. i kazda z tych pozycji dla 4k czyli 8 000 000 px mozna zadresowac dla pixela po ok >>>>1000 wersji na pixel<<< jako zmianiajaca sie z klatki na klatke sume kontrolna to az za duzo bo podobno wystarcza 10-bit czyli potencjalnie w tej sumie kontrolnej mozna zapisac 4k x 100kl = 33bit =3s 33kl 4k = 1000bit =100s 33kl 4k= 65500bit = 100sx65,5 =65500s 33kl 4k = 1,8<2h 33kl 4K
i tych >8 000 000 000 mozliwosci czyli unikalnych paternow naprawde jest i tylko w ten sposob ze mimo odczytu jednej wartosci otrzymujemy adres jednej z 8 000 000 000 kombinacji przemiszan a potrebnych jest max przemieszan 64 000 000 000 000 cyli max przyrostowa waga zmian z klatki na klatke musi utrzymac sie w puli  8 000 razy mniejszej 
nowy pomysl to zamiast na stale przechowywac tak ogromna ilosc patternow mozna bylo by to zanaczaco uproscic aby te kombinacje byly przechowywane w kodzie programu generujacego adhoc potrzebne patterny



czyli najlepiej minuta to 60s 30kl = pojemnosc 1800 notacji ktore potrzba skompresowac

wspolczynnik kompresji dla zstd ok 2,877
Może być zdjęciem przedstawiającym tekst „Compressor name Ratio zstd 1.1.3-1 Compression 2.877 Decompress. 430 MB/s zlib 1.2.8-1 1110 MB/s 2.743 110 MB/s brotli 0.5.2- 400 400 MB/s 2.708 400 MB/s quicklz 1.5.0-1 430 MB/s 2.238 550 MB/s Izo1x 2.09-1 710 MB/s 2.108 Iz4 1.7.5 650 MB/s 830 MB/s 2.101 720 MB/s snappy 1.1.3 3600 MB/s 2.091 Izf 3.6-1 3.6 500 MB/s 1650 MB/s 2.077 400 MB/s 860 MB/s”

wynika z tego ze jest to niemozliwe przy uzyciu standardowego polprzewodnikowego zapisu danych ale mozlwe by bylo na hologramie

i najlepiej za pomoca najdluzszego nieistniejacego w realnym swiecie alfabetu

hologram nalezy traktowac w cudzyslowiu dla tego ze sa sprawdzone metody przesylania i utrwalania danych

wystarczy w strukturze hologramu je przesylac za pomoca tak jak mamy na naklejkach produktów kody kreskowe czy kwadracików które mialyby utrwalony ten bardzo rozlegly alfabet

i np gdy kanal przesylania w tw ma rozpietosc 8 mhz

8x 1024 hz = wystarczjaco dla tego przykladu po kompresji zstd

dla a 8 kanalow tv ale moj przyklad daje 60 razy tyle kanlow bo byl policzony dla 60 sekund

czyli zamiast obecnych 8 kanlow da sie przesylac na jednym muxie 480 stacji

wtedy ten rozlegly alfabet hertz po hertzu mialby inna notacje

pomylka ,,, 8megahertz = 8 x 1024 x 1024 hz

czyli 1000 x 480 = 480 000 stacji tv

tablica alfabetu ktora siedzi sobie po stronie odbiornika lub nadajnika i nie jest przesylana to np dla formatu 4k = 8 000 000 pixeli razy rgb (3=9 kombinacji od 0-8) czyli tablica moze byc o rozmiarze 8 megabajtowym dla jednego hologramu (1hz/s) a ilosc kombinacji czyli pula dla pasma 8mhz wynosi= tez 8 000 000 = 64 000 000 000 000 = 64 biliony

64 bilony = ok 64 terabajty

1TB = 1,099,511,627,776 bajtów

czyli dekoder musialby miec dysk ok 64terabjty pojemnosci na alfabet aby zamiast <<<<<8 stacji>>>>>> tv jak obecnie aby ogladac >>>>>>>480 000 stacji<<<<<<<
nie wiem czy dobrze to policzylem moze tablca 8 megabajtowa bedzie wystarczajaca

aha 64 terabajty /sekunde wynosi obecna waga tych 480 000 stacji / sekunde ok 12.5mbit/sekunde dla 4k x 480 000 stacji = 64 000 000 000 0000 bytes


nowy pomysl to zamiast na stale przechowywac tak ogromna ilosc patternow mozna bylo by to zanaczaco uproscic aby te kombinacje byly przechowywane w kodzie programu generujacego adhoc potrzebne patterny


EN

My idea for an artificial method of improving the image or video quality would be that the image frame would be processed from simple pixels in a plus system and seen as a honeycomb, i.e. from a plus to one honeycomb cell, or from a parallel equilateral octagon - such as a stop sign from those obtained information, it will be much easier to scale 2x or 4x, you can first scale 2x and then repeat the processing but attention,

In this way, there would be distortions in the adjacent slices, so when combining them together, the average color spectrum must be obtained and returned to the top ones, i.e. those external adjoining fields (which would not be original anymore because the image was previously doubled) but this is not it looks logical on the example of a plus, also this sample would have to be such a double-pointed plus before the mathematical process of making these triangles resulting from the sum of the visible light spectrum of neighboring blocks / pixels And probably it would be better to scale the image first without algorithms, i.e. by doubling everything or times a number, and then only apply that's all. dividing the image into plus fields with a connecting element and summarizing the colors in the fields, I figured out that this is not exactly what the honeycomb looks like, the structure of which I wanted to get with a plus, it would be enough to add a half-arm connector that would eventually also become one with two arms As you can see in this simplest example, the image will be 60% enlarged because 4 triangles of a half square = 2 fields + 2 halves of a square = 1 field total 3 and originally plus consisted of 5 fields together gives 8 fields and this is 8 to 5, i.e. 16 to 10 = 1.6 times the size of the image, i.e. 1920 x 1.6 = 3072 pixels widh 1728 height 3072x1728 for example, the resolution of 3k is 2880x1620. add to this good postprocessing I would suggest based on smoothing with the help of the brightness factor in order to obtain the appropriate depth and hide visible imperfections. and from the fullhd picture you get a nice picture for a 4K screen 6 times the size of the image, i.e. 1920 x 1.6 = 3072 pixels. Widh 1728 height 3072x1728, for example, the resolution of 3k is 2880x1620. add to this good postprocessing I would suggest based on smoothing with the help of the brightness factor in order to obtain the appropriate depth and hide visible imperfections. and from the fullhd picture you get a nice picture for a 4K screen 6 times the size of the image, i.e. 1920 x 1.6 = 3072 pixels. Widh 1728 height 3072x1728, for example, the resolution of 3k is 2880x1620. add to this good postprocessing I would suggest based on smoothing with the help of the brightness factor in order to obtain the appropriate depth and hide visible imperfections. and from the fullhd picture you get a nice picture for a 4K screen

https://github.com/devegoo/VED_CODE4CODEC4SCALE/blob/main/resample_01.gif here are shown upscaling algorithms for x2 which gives twice the surface but whether the quality is appropriate, my method, the one I showed some time ago, has a factor of x1.6 in one pass, not doubling, and how would I see pushing up if my algorithm precedes the action like here, i.e. first doubling, for example, with the Lanczos IrfanView algorithm and then pushing or vice versa, it depends on what will be better in visual tests, the magnification factor will be x2 x1.6 or x3.2 and my algorithm in two runs 1x1.6x1.6 = 2.56 and such scaling with my algorithm of material with SD resolution in 2 passes, ie 720x480, for example: 720x2.56 = 1843.2 | 480x2.56 = 1228.8 (1920 x1080 is FHD).

PL

Mój pomysł na sztuczną metode podnoszenia jakości obrazu lub wideo polegałby na tym że klatka obrazu byłaby przetwarzana z prostych pikseli w układzie plus i widziana jak plaster miodu czyli z plusa na jedną komórkę plastra miodu cz też ośmiooboku równobocznego równoległego - taki jak znak stop a z tych otrzymanych informacji już bedzie znacznie łatwiej skalować 2x czy 4x, można najpierw skalować 2x a pożniej powtórzyć przetwarzanie ale uwaga , 

tym sposobem doszło by do przekłamań w sąsiadujących plastrach dla tego podczas łaczenia ich w całość musi dojść do uzyskiwania średniej widma koloru i oddania go spowrotem do  wierzchołkowych czyli tych zewnetrznych stykających się pól (które już nie byłyby oryginalnymi bo obraz był wcześniej podwojony) ale to nie logicznie wygląda na przykładzie plusa takżę ta próbka musiałaby byc takim podwójnoramiennym  plusem przed procesem matematycznym dorabiania tych trójkątów powstałych z sumy widma światła widzialnego sąsiednich bloków/pikseli 
I chyba jednak najpierw by było lepiej przeskalować obraz bez algorytmów czyli podwajając wszystko lub razy ileśtam a pożniej dopiero zastosować to wszystko.
podział obrazu na pola plusowe z elementem łączącym i sumaryzacja kolorów w polach, kapnołem się że tak nie dokładnie wygląda plaster miodu ktorego struktore chcialem uzyskac z plusa to wystrczy taki pol ramienny łącznik dorobic ktory ostatecznie tez z dwuch ramion stanie sie jednym
Jak widać na tym najprostszym przykładzie obraz bedzie o   60% powiększony bo 4 trojkąty połowki kwadratu = 2 pola + 2 połówki kwadratu = 1 pole razem 3 a pierwotnie plus skladał sie z 5 pól razem daje 8 pól a to 8 do 5 czyli 16 do 10 = 1,6 razy większy rozmiar obrazu czyli 1920 x 1.6 = 3072 pixeli widh 1728 height
3072x1728 dla przykładu rozdzielczość 3k wynosi 2880x1620.
dodać do tego dobry postprocessing ja bym proponował bazujący na wygładzaniu przy pomocy  współczynnika jasnośći aby otrzymać odpowidnią głebie i ukryć dostrzegalne niedoskonałości. i z obrazu fullhd otrzymuje sie ładny obraz dl ekranu 4K

https://github.com/devegoo/VED_CODE4CODEC4SCALE/blob/main/resample_01.gif
tu są pokazane algorytmy upscalingu dla x2 co daje dwa razy większą powierzchnie ale czy jakość jest przy tym odpowiednia, mój sposób ten który pokazałem jakiś czas temu ma wsþółczynnik x1.6 w jednym przebiegu nie podwajania a jakbym to powidział rozpychania się , jeśli mój algorytm poprzedzi tak akcja jak tu czyli najpierw podwojenie np algorytmem Lanczos IrfanView a następnie rozpychanie lub odwrotnie zależy co lepiej wypadnie w testach wizualnych to współczynnik powiększenia wyniesie ąż x2 x1.6 czyli x3.2 a samym moim algorytmem w dwuch przebiegach 1x1.6x1.6=2.56 
i takie sklaowanie moim algorytmem materiału o rozdzielczości  SD w 2 przebiegach czyli 720x480 na przykład: 720x2.56=1843.2 | 480x2.56=1228.8 (1920 x1080 to FHD). Można powiedzieć że to idealne rozwiązanie a za razem najmniej skomplikowane a przy tym najbardziej dokładne z pośród dotychczas dostępnych aby otrzymać z rozdzielczości większości kanałów SD w DVB-T/S rozdzielczość prawie FullHD bo 1843.2x1228.8 jest też opcja PAL w Europie i Polsce SD 768x576i = po przemianach 1966.08 x 1474.56 .


https://github.com/devegoo/VED_CODE4CODEC4SCALE/blob/main/upraszczanie%20na%20porcjach%20danych.jpg
mamy tu w sumie 8 pozycji 12342413 a po jednoprzbiegowej kompresji w tym przypadku pozostało operant i pzycje kolejno : +1,+2,-5,1 wartość wejsciowa to pierwsza z puli do przebiegu kompresji mogłaby być oznaczona przedrostkiem 0 pozniej kolejno pozycje 1wartość,2wartosc,3wartosc,4wartosc a operant powtórzenia wartosci pozycji moglby byc zapisywany tam gdzie wystepuje jako podwójna komórka czyli bez przecinka zrobiloby sie poprostu 2 bity w ciągu co by było z automatu rozpoznawane, moc obliczeniowa potrzebna do tego bedzie zalezała od ilośći danych i ilorazu powtórzenia przebiegów , moze to byc uzyte w kompresji i dekompresji RealTime na bardzo słabym obliczeniowo cpu czyli na wszystkim co przychodzi na myśl


(01 -) (10 + )(00 przedrostek wejsciowy)
a wiem jeszcze lepiej jak to ułożyć aby były spójniejsze szeregi danych
(01 bylby -)
(10 bylby +)
(00 poczatkowe dane)
(11 pozycja powtarzająca sie)
czyli wstepnie ciag po pierwszym przbiegu z 1234,(2413) do (+1,+2-5) 1 byłby widziany (10 1), (10 2) (01 5) (11 1)
Decimal to Binary converter skonwertuje te wartości do ciągu (10 1 10 10 01 101 11 1)
przy czym co druga wartość byłaby binarnie zapisana
i program do konpresji i dekompresji dzialalby w trybie mieszanym czyli pierwsza i kążda po-nastepna to znana wartość operanta a druga i każda po-następna to wartość binarna
12342413 - 101111000101010010001101
10 (1) 10 (10) 01 (101) 11 (1) -xx1xx10xx101xx1-1101011
24 ciąg zredukowalem do 6 czyli ratio uzyskałem 4 do 1 bezstratnie

to ma sens poniewaz chyba lepiej zapisac cos ze sie powtarza tylko dwoma pozycjami (binary "red")(11)(19)  np kolor czerwony o danym spektrum rgb jesli wystapil w ciagu danych a kompresor wykryl ze jest on taki sam np 19 razy po uwzglednieniu uchybien nie dostrzegalnych w badaniach porownywalnosci obrazu wejsciowego  z rozkompresowanym

de-compresja barw za pomoca funkcji trygometrycznych F(x)znanych w matematyce.png

curves identification and dump to 2 max 3 point variables.png




1 > 0 < 1 > 0 < 1 < 2 > 1 < 8 > 6 (>) > 0 > 0 > 1 > 6
AI Image processing" według mojego pomysłu na który wpadłem przed chwilą wyglądałby na coś w ten deseń że. dla wartości opisujących każdego pixela i sąsiadujące z nim w czterech kierunkach pixeli "+" można by było na tej wartości z pixela głownego i sąsiednich wypisać ciąg danych np 3(pixel głowny) - 2( pixel wrzedzie poprzedni) +1 (pixel w rzedzie kolejnym) -,- 4 (pixel w rzędzie poprzednim nad pixelem głownym) +,+6( pixel wrzedzie kolejnym pod pixelem głownym), Wtedy mamy taki ciąg danych:
 ,a3,b2,c1,d4,e6
i z takim ciągiem można robic co sie żywnie podoba stosując różne znane algorytmy matematyczne wg uznania , można zastosówać  wykrywanie w którym kierunku mając już kilka opisanych w zasobie np 32x32 px jest wzrost wartości rgb typu red green blue i ntej podstawie opisywać wektory potrzebne dla różnych filtrów które były by stosowane w rożnych celach np: w inteligentym podnoszeniu jakości zdjęć/grafik lub video , zbiór takich danych mógłby się przydać w AI paintingu processingu foto/video lub w wykrywać którym kierunku coś się porusza





Najprostsza porcja danych to będzie = zero (piksel nie podświetlony - czerń)
Najbardziej skomplikowana to kolor zapisany w 12 bit po dekompresji z 12 bit (kompresja zerowa)
Później stopień 75% 9 bit , 50% 6 bit i 25% 3 bit
Dla obrazu fullhd 1920x1080 pikseli = 2,073,600 pix , x 33,333 klatki /sekundę x 12 bit daje przy 100hz , 2073600x33,33,3x12= 829,431,706 cyferek 0/1 co wynosi /8 = 103,678,963 bajtów dalej / 1024 kilobajty = 101,248.987 kB / mb = 98.8759639 mb dla 100 klatek nieskompresowanych lub ok 25 mb dla 25 kl nieskompresowanych na sekundę full HD 25 % 6,25 50% 12,5 mb 75% 18,75 mb i 50% dla 1080i czyli 3,125mb (25%) - 9,375mb dla 75% kompresji max 12,50 mb

Wyniki X4 dla 4k , x16 dla 8k.
Czyli w najlepszym wypadku 8k 25% inerlaced = ok 50 Mbit/s do 200 Mbit nieskompresowany.
4k 25% intelaced = 12,5 Mbit/s
Dac miał kompresję zapisu stanu diody pomiedzy 0 , 3 bit a 12 bit a tu codec ma 4 bit np jak w tym przykładzie wynik 0 Hex 00 W tamtym przykładzie dla 33 klatek 100hz Dla obrazu fullhd 1920x1080 pikseli = 2,073,600 pix , x 33,333 klatki /sekundę x 4 bit daje 276477235,2 /8/1024/1024= 32,95 100% ok 4,11 Mbit/s 1080i 25% Czyli wg mojego kodeka obraz fullhd 1080i da się przesyłać na łączu 4-8 Mbit wynik dac musi miec przepustowosc dla 4k 25% intelaced = 12,5 Mbit/s a codec dla 4k i 16mbit/s 25(%) comp ratio dac 0,25 x x 32mb (4k 100%) =8 mb (przy comp 25x25) / interlaced 4 Mb = od 4-16 mb interlaced 4k lub 8 - 32mbit 4k progressive 4k da sie ogladac przy 12 mbit/sekunde ... To 1,5mb na dysku/d 60s 90 mb 1h = 540mb (4k interlaced ~75%comp) aha jeszcze zapomnialem o o algorytmie... constant/print  


UPDATE 2022/11/2

myslalem przed chwila wlasnie o nowej metodzie kompresji AI ale narazie dla ogolnego zastosowania ktora tez ma cechy AI jak ponizej w tym codec-u audio opublikowanym przez Meta EnCodec (facebook) i po dluzszych przemysleniach nad swoimi wczesniejszymi opracowywaniami w tej dziedzinie wymyslilem cos lepszego co by bylo zarowno i proste w implementacji i proste do zrozumienia . w tym nowym kodeku nie byloby tzw padow dla porcji danych bo odpowiednio podzielone porcje danych bylyby oczywiste dla dekompresora przez co porcja danych zmiejszy sie juz o ok 1/3 (haha) najzwyczajniej dekompresor rozpozna ze jest to ciag danych binarnych nalezacych do danej funkcji po strukturze tych danych czyli policzeniu ich , i jesli bedzie to wideo 16:9 to chyba jedyna informacja jaka mu bedzie potrzebna do odgadniecia to jest to gdzie konczy sie dajmy na to 1 sekunda (30 lub 60kl) dla pixela a to bedzie mogl odgadnac dekompresor z samego bitrate/sek z transmitowanego wideo, ale to jest jeszcze nie ten element AI , elementem AI w tym kodzie/prymitywie bedzie to ze beda tzw AI-unprisoned-flares-for-pull-off-pixels/data(0/1)-in-vectors-and-time (lava lamp)

o-x.jpg
Najprostszy przyklad/cwiczenie dla algorytmu kompresji AI o ktorej mowilem bedzie opracowanie jak najmniejszego a zarazem najszybszego kodu dla zakodowania a poznioej odkodowania toku rozgrywnki tej o to prostej gry kolko krzyzyk ale dowolnej tego typu rozgrywki czyli kod mosialby rozpoznac x / o i jakie sa kolejne pola wystepowania x / o i zapisac ten dowolny tok wystepowania jaknajszybciej i jak najmiej danych uzywajac ///kod nalezy opracowac obiektowo ,jesli uda sie takowy kod jaknajlepiej opracowac to bedzie on bardzo przydatny w wielu etapach /stage-ach, wykorzystamy to do  jedankowych wystapien na roznych poziomach kodu tego kompresora
czyli gdyby to byla jedna sekunda wideo (5-klatek wideo o res 3x3)
i bylby to nawet nie czarno bialy obraz tylko kwadraty czarne i biale
tok postepowania dla 1 sekundy:
0.wykryc bitrate do czasu jednej sekundy i jesli jest on o jakiejs wielkosci stalej dla zdefiniowanych typow rozdzielczosci - proporcji zastosowac odpowiedni wariant algorytmu / preset
1.pule danych-T-Data(1s-Time) podzielic przez 5 (klatki-frames)
2.pol-Poles mamy =9 tak wiec =9 adresow -P-Adress dla kazdej klatki
3.pod kazdym z adresow P-Adress(1-9) kod wypisuje =0 dla pola bialego lub =1 dla pola czarnego np
 100000000, 100100000, 100100100, 110100100, 111100100
4. nastepnie dla kazdego z adresow wylicza jak zminial sie klatka po klatce
czyli 11111,00011,00001,01111,00000,00000,00010,00000,00000 ale to nam prawie nic nie jedynie jak mozna zauwazyc pojawilo sie  4 razy 000000 a wczesniej nie bylo takiego ujednolicenia/co wcale w realnym swiecie nie musi sie zdazyc
5. i tu tak naprawde tkwi sedno bo mamy w polu 9 polowym 81 kombinacji rozmieszczen czyli od 0-80 a w czasie czyli tych 9 polach w pieciu klatkach 81x5 = 405 kobinacji dla 5 klatek 
hahaha i mamy to ,
 czyli jak widzicie za pomoca jednego predefiniowanego patterna /zaadresowanej kombinacji dajmy na to 234 na przyklad adresu da sie wszystko z tych 9 pol i 5 klatek ogarnac do jedengo zapisu/adresu puli danych=234 gdzie kod programu dokladnie wie co rozpakowac klatka po klatce w tym przedziale czasu dla tych danych dla 5 klatek 
i wcale tych 5 klatek nie potrzeba potengowac do kwadratu bo to jest dalej rozpatrywane jako 81 tylko z klatki 1 na klatke 5 zsumowana rzeczywistosc w czasie tych wariantow wynosi 405 a dla tego rozpatrywac mozna to w czasie gdyz jaki to obecnie problem wczytac do pamieci ram iles nawet tysiecy paternow dla jeszcze bardziej zkomplikowanych  presetow chyba 64x64 =4096 x 60 klatek/s = 245760 ,ciag 245~ kilobitow= 30Kbajt dla 60 klatek a dla 30kl 122 kb 
obecnie hevc dla 1080/30kl to ok 4Mbit / s 
policzmy dla mojego przykladu: 1080x1920x30kl 2073600 = ~1000x1000x2(x30) /
1000x1000 byloby podstawa dla makrobloka czyli 1000000 kombinacji x 2 x 30 = 60 000 000 kombianacji = 1sek full hd 30 kl/s=  60 000 kbitow/s = /8 (bajt) = >>>>>>>5,250 mbajt<<<<<<<<<<<< 1 sek (30 kl fhd) co daje dobra podstawe do reszty aplikacji
czyli 1h fhd 30 kl/s = x 3600 === 1890mbajt 
a jest jeszcze cos takiego jak transmsja 1080i i wtedy dzieli sie wynik przez 2 = 2.625 mbit/s = 900 mb(1h)
dalsze mozliwe zabiegi polegalyby na skopresowaniu samych paternow a wlasciwie kazdego z pojedyncza jakims zgrabnym algorytmem na przykladzie sortowania tych dluzszych paternow ta sama metoda czyli 999999 czyli co da 60pol xyz(3x2x10- bo od 0 do 9 = 6z [z=0-9])(a,b,c,d,e,f,-0-9) kombinacji[  i te kmbinacje zapisac na nizszym podrecznym poziomie i z nich bezposrednio po pomocnym dekodowaniu wyluskywac wlasciwe dane
a jesli brac pod uwage ze transmisja nie jest na zywo tylko retransmitowana a odbiornik ma cache do buforowania np 5 sek opznienia to te 5 sekund mozna juz kompresowac jakimkolwiek compresorem real-time
w informatyce jest tak ze jak cos swietnie dziala na skeletonie/prymitywie to nie ma problemu aby dawalo rade w realiach
i jesli to sie uda zrobic to nastepnie mozna myslec juz o wiekszych i zarazem bardziej oblozonych strukturach danych

ubdate 13.11.2022

1_0-adressing.jpg

01-adressing from packaeges (pool of data) for compression
 when  for 1 where is less adresses than  0 
occured in package or
when for 0  where is less adresses  than 1
if "weight a" < "weight b" compress "a"
if "weight b" < "weight a" compress "b"

żonglowanie kolorami i ich dedukcja 
"sprawdż czy to ci sie sprawdza"
ktos moze sie sprzeczac ze tak wyszlo po rowno bo na krzyz suma dzielona na 4 to tez 5 ale ja to tylko na przykladzie najprostszych cyferek przedstawilem, realnie bylby to w gorszej jakosci obrazu porównywany pixel a raczej jego np z 16bitowej palety zapis lub wg zapisu rgb/itp i znając już nawet ten pojedynczy pixel/jego unikalna wartosc wg reverse enginering czyli kodowanie wstecznego mozna opracowac model lingwistyczny jak to sie ma gdy ten sam obraz jest fotografowany aparatem vga porownojac to z aparatem 2xVga i wtedy to matematyczne stwierdzenie uwzglednic w ty zapisie kodu reverse-enginering i wtedy znajac wartosc pixela i kod/model lingwistyczny dla danej przestrzeni barw to sie sprawdzi a tym modelem lingwistycznym jest wlasnie to co tu zapisałem

